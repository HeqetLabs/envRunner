#!/usr/bin/env python
"""envRunner is a command wrapper that provides configuration through environment variables.

These variables can be set from a multitude of sources.

Examples:
    envRunner test.yml exec some_command params
    envRunner test.json exec some_command params
    envRunner http://test.com/test.yml exec some_command params
    envRunner http://test.com/test.json exec some_command params

Example test.yml:

  HELLO: world
  TESTING: 123

Example test.json:

  {
    "HELLO": "world",
    "TESTING": 123
  }

Each of the above will read the configuration file
and then merge the values inside of that with the 
environment of the subprocess.

Usage:
  envRunner (-h | --help)
  envRunner <config> exec [COMMAND ...]

Options:
  -h --help   Shows this screen.
  --version
"""

from docopt import docopt
from urlparse import urlparse
import json
import os
import requests
import signal
import subprocess
import sys
import yaml

class SigIntHandler:
  def __init__(self, process):
    self.process = process

  def __call__(self, signal, fname):
    self.process.terminate() 
    sys.exit(0)

class HttpRunner:
  def __init__(self, url):
    self.url = url
    self.environment = self._read_remote_file()

  def _read_remote_file(self):
    r = requests.get(self.url)

    try:
      return json.loads(r.text)
    except (ValueError):
      return yaml.load(r.text)

  def __call__(self):
    pass

class LocalRunner:
  def __init__(self, url):
    self.url = url
    self.environment = self._read_local_file()

  def _read_local_file(filename):
    _,ext = os.path.splitext(filename)
    ext = ext.lower()

    if ext == ".yaml" or ext == ".yml":
      return self._read_yaml_file(filename)
    elif ext == ".js" or ext == ".json":
      return self._read_json_file(filename)
    else:
      raise Exception("Could not read" + filename)

  def _read_yaml_file(filename):
    return yaml.load(open(filename, "r"))

  def _read_json_file(filename):
    return json.load(open(filename, "r"))

  def __call__(self, command):
    env = dict(os.environ, **{ k: str(environment[k]) for k in environment})
    self.process = subprocess.Popen(command, env=env)

    sigintHandler = SigIntHandler(process)
    signal.signal(signal.SIGINT, sigintHandler)

    process.wait()

class TimeBasedPoller:
  def __init__(self, interval):
    self.interval = interval
    self.running = True

  def __call__(self):
    while self.running:
      pass


if __name__ == '__main__':
  arguments = docopt(__doc__, version='envRunner v0.1.6', options_first=True)
  parsed_uri = urlparse(arguments["<config>"])

  if "http" in parsed_uri.scheme:
    runner = HttpRunner(parsed_uri.getUrl())
  elif "file" in parsed_uri.scheme or parsed_uri.scheme == "":
    runner = LocalRunner(parsed_uri.path)

  if arguments["exec"]:
    runner(arguments["COMMAND"])

